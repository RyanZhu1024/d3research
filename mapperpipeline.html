<!DOCTYPE html>
<meta charset="utf-8">

<head>
  <title>mapper Pipeline</title>
</head>
<style>
  .node {
    stroke: #fff;
    stroke-width: 1.5px;
  }

  .link {
    stroke: #999;
  }
</style>

<body>
  <script src="https://d3js.org/d3.v5.min.js"></script>
  <script>

    const width = window.innerWidth,
      height = window.innerHeight;
    const nodes = [
      { nodex: 66, nodey: 10, label: 'mapper', cx: null, cy: null },
      { nodex: 150, nodey: 50, label: 'join', cx: null, cy: null },
      { nodex: 250, nodey: 80, label: 'rest get', cx: null, cy: null }
    ];
    let links = [];
    const rectSize = 62;
    // links.forEach(d => {
    //   d.source = nodes[d.source];
    //   d.target = nodes[d.target];
    // })
    const svg = d3.select("body").append("svg")
      .attr("width", width)
      .attr("height", height);
    const root = svg.append('g');
    function zoomed() {
      root.attr("transform", d3.event.transform);
    }
    svg.call(d3.zoom()
      .extent([[0, 0], [width, height]])
      .scaleExtent([-8, 8])
      .on("zoom", zoomed));
    const nodeGroup = root.append('g')
      .selectAll('rect')
      .data(nodes)
      .enter()
      .append('rect')
      .attr('height', rectSize)
      .attr('width', rectSize)
      .attr('x', d => d.nodex)
      .attr('y', d => d.nodey)
      .attr('fill', '#79A1E2');
    const getLabelX = d => d.nodex + rectSize / 2;
    const getLabelY = d => d.nodey + rectSize / 2;
    const labelsGroup = root.append('g')
      .selectAll('text')
      .data(nodes)
      .enter()
      .append('text')
      .attr('x', getLabelX)
      .attr('y', getLabelY)
      .attr('font-size', 12)
      .attr("text-anchor", "middle")
      .attr('font-weight', 'bold')
      .attr('line-spacing', 11)
      .attr('fill', '#000000')
      .attr('cursor', 'default')
      .text(d => d.label);
    const getTailLineX1 = d => d.nodex - 5;
    const getTailLineY1 = d => d.nodey + rectSize / 2;
    const getTailLineX2 = d => d.nodex - 3;
    const getTailLineY2 = d => d.nodey + rectSize / 2;
    const getTailRingX = d => d.nodex - 20;
    const getTailRingY = d => d.nodey + rectSize / 2;
    const tailLineGroup = root.append('g')
      .selectAll('line')
      .data(nodes)
      .enter()
      .append('line')
      .attr('stroke', '#9B9B9B')
      .attr('stroke-width', 6)
      .attr('stroke-linecap', 'square')
      .attr('x1', getTailLineX1)
      .attr('y1', getTailLineY1)
      .attr('x2', getTailLineX2)
      .attr('y2', getTailLineY2)
    const getTailRingPosition = d => `translate(${getTailRingX(d)}, ${getTailRingY(d)}) rotate(45) translate(-17, -17)`
    const tailRingGroup = root.append('g').attr('id', 'tailRingGroup')
      .selectAll('path')
      .data(nodes)
      .enter()
      .append('path')
      .attr('d', 'M17,29 C23.627417,29 29,23.627417 29,17 C29,10.372583 23.627417,5 17,5 C10.372583,5 5,10.372583 5,17')
      .attr('stroke-width', 2.5)
      .attr('transform', getTailRingPosition)
      .attr('stroke', '#9B9B9B')
      .attr('fill', 'none');
    const getHeadLineX1 = d => d.nodex + rectSize + 3;
    const getHeadLineY1 = d => d.nodey + rectSize / 2;
    const getHeadLineX2 = d => d.cx || d.nodex + rectSize + 5;
    const getHeadLineY2 = d => d.cy || d.nodey + rectSize / 2;
    const headLineGroup = root.append('g').attr('id', 'headLineGroup')
      .selectAll('line')
      .data(nodes)
      .enter()
      .append('line')
      .attr('stroke', '#9B9B9B')
      .attr('stroke-width', 6)
      .attr('stroke-linecap', 'square')
      .attr('x1', getHeadLineX1)
      .attr('y1', getHeadLineY1)
      .attr('x2', getHeadLineX2)
      .attr('y2', getHeadLineY2);
    const R = 9;
    const getHeadRingCX = d => {
      return d.cx || d.nodex + rectSize + 5 + R
    };
    const getHeadRingCY = d => d.cy || d.nodey + rectSize / 2;
    const headRingGroup = root.append('g')
      .selectAll('circle')
      .data(nodes)
      .enter()
      .append('circle')
      .attr('stroke', '#9B9B9B')
      .attr('stroke-width', 2)
      .attr('fill', '#CCDCEE')
      .attr('cx', getHeadRingCX)
      .attr('cy', getHeadRingCY)
      .attr('r', R)
      .attr('cursor', 'pointer');
    function updateNode(node) {
      node.attr('x', d => d.nodex)
        .attr('y', d => d.nodey);
    }
    function updateLabel(label) {
      label.attr('x', getLabelX)
        .attr('y', getLabelY)
    }
    function updateTailLine(tailLine) {
      tailLine.attr('x1', getTailLineX1)
        .attr('y1', getTailLineY1)
        .attr('x2', getTailLineX2)
        .attr('y2', getTailLineY2)
    }
    function updateTailRing(tailRing) {
      tailRing.attr('transform', getTailRingPosition)
    }
    function updateHeadLine(headLine) {
      headLine.attr('x1', getHeadLineX1)
        .attr('y1', getHeadLineY1)
        .attr('x2', getHeadLineX2)
        .attr('y2', getHeadLineY2);
    }
    function updateHeadRing(headRing) {
      headRing.attr('cx', getHeadRingCX)
        .attr('cy', getHeadRingCY)
    }
    function update() {
      nodeGroup.call(updateNode);
      labelsGroup.call(updateLabel);
      tailLineGroup.call(updateTailLine);
      tailRingGroup.call(updateTailRing);
      headLineGroup.call(updateHeadLine);
      headRingGroup.call(updateHeadRing);
    }
    function dragNodeStart(d) {
      d3.event.sourceEvent.stopPropagation();
      d3.select(this).raise().attr('stroke', 'black').attr('cursor', 'grab');
    }
    function draggingNode(d) {
      d.nodex = d3.event.x;
      d.nodey = d3.event.y;
      links.forEach(link => {
        if (link.source === d) {
          // pass
        }
        if (link.target === d) {
          link.source.cx = getTailRingX(d);
          link.source.cy = getTailRingY(d);
        }
      })
      update();
    }
    function dragNodeEnd() {
      d3.select(this).attr('stroke', null).attr('cursor', null);
    }
    function dragLabelStart(d, i) {
      d3.event.sourceEvent.stopPropagation();
      d3.select(this).attr('cursor', 'grab');
      const found = d3.selectAll('rect').filter(rect => rect === d);
      if (found && found.size() === 1) {
        found.raise().attr('stroke', 'black');
      }
    }
    function draggingLabel(d) {
      d.nodex = d3.event.x;
      d.nodey = d3.event.y;
      links.forEach(link => {
        if (link.source === d) {
          // pass
        }
        if (link.target === d) {
          link.source.cx = getTailRingX(d);
          link.source.cy = getTailRingY(d);
        }
      })
      update();
    }
    function dragLabelEnd(d) {
      d3.select(this).attr('cursor', 'default');
      const found = d3.selectAll('rect').filter(rect => rect === d);
      if (found && found.size() === 1) {
        found.raise().attr('stroke', null);
      }
    }
    function dragHeadRingStart(d) {
      d3.select(this).raise().attr('stroke', 'black');
    }
    function draggingHeadRing(d) {
      d.cx = d3.event.x;
      d.cy = d3.event.y;
      update();
    }
    function dragHeadRingEnd(d) {
      d3.select(this).raise().attr('stroke', '#9B9B9B');
      d3.select('#tailRingGroup').selectAll('path').filter((tail) => {
        if (tail !== d) {
          const tailRingX = getTailRingX(tail);
          const tailRingY = getTailRingY(tail);
          const distance = Math.sqrt(Math.pow((tailRingX - d3.event.x), 2) + Math.pow((tailRingY - d3.event.y), 2));
          if (distance > 10) {
            d.cx = null;
            d.cy = null;
            links = links.filter(link => link.source !== d || link.target !== tail);
          } else {
            d.cx = tailRingX;
            d.cy = tailRingY;
            links.push({ source: d, target: tail })
          }
          update();
        }
      })
    }
    nodeGroup.call(d3.drag().subject(d => ({ x: d.nodex, y: d.nodey })).on('start', dragNodeStart).on('drag', draggingNode).on('end', dragNodeEnd));
    labelsGroup.call(d3.drag().subject(d => ({ x: d.nodex, y: d.nodey })).on('start', dragLabelStart).on('drag', draggingLabel).on('end', dragLabelEnd));
    headRingGroup.call(d3.drag().subject(d => ({ x: d.cx || getHeadRingCX(d), y: d.cy || getHeadRingCY(d) })).on('start', dragHeadRingStart).on('drag', draggingHeadRing).on('end', dragHeadRingEnd));
  </script>